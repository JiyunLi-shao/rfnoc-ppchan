--------------------------------------------------------------------------------
-- (c) Copyright 2011 - 2013 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
-- Description:
-- This is an example testbench for the FIR Compiler IP core.
-- The testbench has been generated by Vivado to accompany the IP core
-- instance you have generated.
--
-- This testbench is for demonstration purposes only.  See note below for
-- instructions on how to use it with your core.
--
-- See the FIR Compiler product guide for further information
-- about this core.
--
--------------------------------------------------------------------------------
-- Using this testbench
--
-- This testbench instantiates your generated FIR Compiler core
-- instance named "channelizer_fir_compiler_v7_2_i0".
--
-- Use Vivado's Run Simulation flow to run this testbench.  See the Vivado
-- documentation for details.
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_channelizer_fir_compiler_v7_2_i0 is
end tb_channelizer_fir_compiler_v7_2_i0;

architecture tb of tb_channelizer_fir_compiler_v7_2_i0 is

  -----------------------------------------------------------------------
  -- Timing constants
  -----------------------------------------------------------------------
  constant CLOCK_PERIOD : time := 100 ns;
  constant T_HOLD       : time := 10 ns;
  constant T_STROBE     : time := CLOCK_PERIOD - (1 ns);

  -----------------------------------------------------------------------
  -- DUT signals
  -----------------------------------------------------------------------

  -- General signals
  signal aclk                            : std_logic := '0';  -- the master clock
  signal aresetn                         : std_logic := '1';  -- synchronous active low reset
  signal aclken                          : std_logic := '1';  -- clock enable

  -- Data slave channel signals
  signal s_axis_data_tvalid              : std_logic := '0';  -- payload is valid
  signal s_axis_data_tready              : std_logic := '1';  -- slave is ready
  signal s_axis_data_tdata               : std_logic_vector(47 downto 0) := (others => '0');  -- data payload
  signal s_axis_data_tlast               : std_logic := '0';  -- indicates end of packet

  -- Config slave channel signals
  signal s_axis_config_tvalid            : std_logic := '0';  -- payload is valid
  signal s_axis_config_tready            : std_logic := '1';  -- slave is ready
  signal s_axis_config_tdata             : std_logic_vector(7 downto 0) := (others => '0');  -- data payload
  signal s_axis_config_tlast             : std_logic := '0';  -- indicates end of packet

  -- Data master channel signals
  signal m_axis_data_tvalid              : std_logic := '0';  -- payload is valid
  signal m_axis_data_tready              : std_logic := '1';  -- slave is ready
  signal m_axis_data_tdata               : std_logic_vector(79 downto 0) := (others => '0');  -- data payload
  signal m_axis_data_tlast               : std_logic := '0';  -- indicates end of packet

  -- Event signals
  signal event_s_config_tlast_missing    : std_logic  :=  '0';  -- s_axis_config_tlast low at end of config packet
  signal event_s_config_tlast_unexpected : std_logic  :=  '0';  -- s_axis_config_tlast high not at end of config packet

  -----------------------------------------------------------------------
  -- Aliases for AXI channel TDATA and TUSER fields
  -- These are a convenience for viewing data in a simulator waveform viewer.
  -- If using ModelSim or Questa, add "-voptargs=+acc=n" to the vsim command
  -- to prevent the simulator optimizing away these signals.
  -----------------------------------------------------------------------

  -- Data slave channel alias signals
  signal s_axis_data_tdata_path0       : std_logic_vector(17 downto 0) := (others => '0');
  signal s_axis_data_tdata_path1       : std_logic_vector(17 downto 0) := (others => '0');

  -- Config slave channel alias signals
  signal s_axis_config_tdata_filter_select    : std_logic_vector(6 downto 0) := (others => '0');

  -- Data master channel alias signals
  signal m_axis_data_tdata_path0       : std_logic_vector(33 downto 0) := (others => '0');
  signal m_axis_data_tdata_path1       : std_logic_vector(33 downto 0) := (others => '0');


begin

  -----------------------------------------------------------------------
  -- Instantiate the DUT
  -----------------------------------------------------------------------

  dut : entity work.channelizer_fir_compiler_v7_2_i0
    port map (
      aclk                            => aclk,
      aresetn                         => aresetn,
      aclken                          => aclken,
      s_axis_data_tvalid              => s_axis_data_tvalid,
      s_axis_data_tready              => s_axis_data_tready,
      s_axis_data_tdata               => s_axis_data_tdata,
      s_axis_data_tlast               => s_axis_data_tlast,
      s_axis_config_tvalid            => s_axis_config_tvalid,
      s_axis_config_tready            => s_axis_config_tready,
      s_axis_config_tdata             => s_axis_config_tdata,
      s_axis_config_tlast             => s_axis_config_tlast,
      m_axis_data_tvalid              => m_axis_data_tvalid,
      m_axis_data_tready              => m_axis_data_tready,
      m_axis_data_tdata               => m_axis_data_tdata,
      m_axis_data_tlast               => m_axis_data_tlast,
      event_s_config_tlast_missing    => event_s_config_tlast_missing,
      event_s_config_tlast_unexpected => event_s_config_tlast_unexpected
      );

  -----------------------------------------------------------------------
  -- Generate clock
  -----------------------------------------------------------------------

  clock_gen : process
  begin
    aclk <= '0';
    wait for CLOCK_PERIOD;
    loop
      aclk <= '0';
      wait for CLOCK_PERIOD/2;
      aclk <= '1';
      wait for CLOCK_PERIOD/2;
    end loop;
  end process clock_gen;

  -----------------------------------------------------------------------
  -- Generate inputs
  -----------------------------------------------------------------------

  stimuli : process

    -- Procedure to drive a number of input samples with specific data
    -- data is the data value to drive on the tdata signal
    -- samples is the number of zero-data input samples to drive
    procedure drive_data ( data    : std_logic_vector(47 downto 0);
                           samples : natural := 1 ) is
      variable ip_count : integer := 0;
    begin
      ip_count := 0;
      loop
        s_axis_data_tvalid <= '1';
        s_axis_data_tdata  <= data;
        if ip_count = samples - 1 then
          s_axis_data_tlast <= '1';  -- Use TLAST to indicate the last sample in a single call of this procedure
        else
          s_axis_data_tlast <= '0';
        end if;
        loop
          wait until rising_edge(aclk);
          exit when s_axis_data_tready = '1';
        end loop;
        ip_count := ip_count + 1;
        wait for T_HOLD;
        exit when ip_count >= samples;
      end loop;
    end procedure drive_data;

    -- Procedure to drive a number of zero-data input samples
    -- samples is the number of zero-data input samples to drive
    procedure drive_zeros ( samples : natural := 1 ) is
    begin
      drive_data((others => '0'), samples);
    end procedure drive_zeros;

    -- Procedure to drive an impulse and let the impulse response emerge on the data master channel
    -- samples is the number of input samples to drive; default is enough for impulse response output to emerge
    procedure drive_impulse ( samples : natural := 3328 ) is
      variable impulse : std_logic_vector(47 downto 0);
    begin
      impulse := (others => '0');  -- initialize unused bits to zero
      impulse(17 downto 0) := "010000000000000000";
      drive_data(impulse);
      if samples > 1 then
        drive_zeros(samples-1);
      end if;
    end procedure drive_impulse;

    -- Local variables
    variable data : std_logic_vector(47 downto 0);

  begin

    -- Drive inputs T_HOLD time after rising edge of clock
    wait until rising_edge(aclk) and aresetn = '1' and aclken = '1';
    wait for T_HOLD;

    -- Drive a single impulse and let the impulse response emerge
    drive_impulse;

    -- Drive another impulse, during which demonstrate use and effect of AXI handshaking signals
    drive_impulse(2);  -- start of impulse; data is now zero
    s_axis_data_tvalid <= '0';
    wait for CLOCK_PERIOD * 5;  -- provide no data for 5 input samples worth
    drive_zeros(2);  -- 2 normal input samples
    m_axis_data_tready <= '0';
    drive_zeros(10);  -- stop accepting outputs for 10 input samples worth
    m_axis_data_tready <= '1';
    drive_zeros(3314);  -- back to normal operation

    -- Drive another impulse, during which demonstrate:
    --   clock enable (aclken)
    --   reset (aresetn)
    drive_impulse(668);  -- to partway through impulse response
    aclken <= '0';
    wait for CLOCK_PERIOD * 5;  -- 5 input samples worth
    aclken <= '1';
    drive_zeros(595);
    s_axis_data_tvalid <= '0';
    aresetn <= '0';  -- assert reset (active low)
    wait for CLOCK_PERIOD * 2;  -- hold reset active for 2 clock cycles, as recommended in FIR Compiler Datasheet
    aresetn <= '1';  -- deassert reset
    drive_impulse;  -- send new impulse, following reset

    -- Drive a set of impulses of different magnitudes on each path
    -- Path inputs are provided in parallel, in different fields of s_axis_data_tdata
    data := (others => '0');  -- initialize unused bits to zero
    data(17 downto 0) := "010000000000000000";  -- path 0: impulse >> 0
    data(41 downto 24) := "001000000000000000";  -- path 1: impulse >> 1
    drive_data(data);
    drive_zeros(3327);

    -- Drive a set of impulses of different magnitudes on each channel
    -- Channel inputs are provided in TDM fashion
    data := (others => '0');  -- initialize unused bits to zero
    data(17 downto 0) := "010000000000000000";  -- channel 0: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 1: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 2: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 3: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 4: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 5: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 6: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 7: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 8: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 9: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 10: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 11: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 12: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 13: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 14: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 15: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 16: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 17: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 18: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 19: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 20: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 21: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 22: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 23: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 24: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 25: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 26: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 27: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 28: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 29: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 30: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 31: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 32: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 33: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 34: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 35: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 36: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 37: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 38: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 39: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 40: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 41: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 42: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 43: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 44: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 45: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 46: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 47: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 48: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 49: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 50: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 51: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 52: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 53: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 54: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 55: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 56: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 57: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 58: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 59: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 60: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 61: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 62: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 63: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 64: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 65: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 66: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 67: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 68: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 69: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 70: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 71: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 72: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 73: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 74: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 75: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 76: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 77: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 78: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 79: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 80: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 81: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 82: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 83: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 84: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 85: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 86: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 87: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 88: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 89: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 90: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 91: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 92: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 93: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 94: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 95: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 96: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 97: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 98: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 99: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 100: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 101: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 102: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 103: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 104: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 105: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 106: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 107: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 108: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 109: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 110: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 111: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 112: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 113: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 114: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 115: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 116: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 117: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 118: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 119: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 120: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 121: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 122: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 123: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 124: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 125: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 126: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 127: impulse >> 8
    drive_data(data);
    drive_zeros(3200);

    -- Select different filter coefficient sets for each TDM channel using the config slave channel
    s_axis_data_tvalid <= '0';
    for channel in 0 to 127 loop
      s_axis_config_tvalid <= '1';
      s_axis_config_tdata <= (others => '0');  -- clear unused bits of TDATA
      s_axis_config_tdata(6 downto 0) <= std_logic_vector(to_unsigned(channel, 7));  -- incrementing sets (range 0 to 127)
      if channel = 127 then
        s_axis_config_tlast <= '1';  -- signal last transaction in config packet
      else
        s_axis_config_tlast <= '0';
      end if;
      loop
        wait until rising_edge(aclk);
        exit when s_axis_config_tready = '1';
      end loop;
      wait for T_HOLD;
    end loop;
    s_axis_config_tvalid <= '0';

    -- Now send a zero data packet on the data slave channel, to synchronize and consume the config channel packet
    drive_zeros(128);

    -- The filter coefficient set configuration has now taken effect.
    -- Drive a set of impulses of different magnitudes on each channel to show the new configuration.
    -- Channel inputs are provided in TDM fashion
    data := (others => '0');  -- initialize unused bits to zero
    data(17 downto 0) := "010000000000000000";  -- channel 0: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 1: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 2: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 3: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 4: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 5: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 6: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 7: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 8: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 9: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 10: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 11: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 12: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 13: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 14: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 15: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 16: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 17: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 18: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 19: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 20: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 21: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 22: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 23: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 24: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 25: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 26: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 27: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 28: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 29: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 30: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 31: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 32: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 33: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 34: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 35: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 36: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 37: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 38: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 39: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 40: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 41: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 42: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 43: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 44: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 45: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 46: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 47: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 48: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 49: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 50: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 51: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 52: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 53: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 54: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 55: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 56: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 57: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 58: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 59: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 60: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 61: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 62: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 63: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 64: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 65: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 66: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 67: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 68: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 69: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 70: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 71: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 72: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 73: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 74: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 75: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 76: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 77: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 78: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 79: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 80: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 81: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 82: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 83: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 84: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 85: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 86: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 87: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 88: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 89: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 90: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 91: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 92: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 93: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 94: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 95: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 96: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 97: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 98: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 99: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 100: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 101: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 102: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 103: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 104: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 105: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 106: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 107: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 108: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 109: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 110: impulse >> 8
    drive_data(data);
    data(17 downto 0) := "000000000010000000";  -- channel 111: impulse >> 9
    drive_data(data);
    data(17 downto 0) := "000000000001000000";  -- channel 112: impulse >> 10
    drive_data(data);
    data(17 downto 0) := "000000000000100000";  -- channel 113: impulse >> 11
    drive_data(data);
    data(17 downto 0) := "000000000000010000";  -- channel 114: impulse >> 12
    drive_data(data);
    data(17 downto 0) := "000000000000001000";  -- channel 115: impulse >> 13
    drive_data(data);
    data(17 downto 0) := "000000000000000100";  -- channel 116: impulse >> 14
    drive_data(data);
    data(17 downto 0) := "000000000000000010";  -- channel 117: impulse >> 15
    drive_data(data);
    data(17 downto 0) := "000000000000000001";  -- channel 118: impulse >> 16
    drive_data(data);
    data(17 downto 0) := "010000000000000000";  -- channel 119: impulse >> 0
    drive_data(data);
    data(17 downto 0) := "001000000000000000";  -- channel 120: impulse >> 1
    drive_data(data);
    data(17 downto 0) := "000100000000000000";  -- channel 121: impulse >> 2
    drive_data(data);
    data(17 downto 0) := "000010000000000000";  -- channel 122: impulse >> 3
    drive_data(data);
    data(17 downto 0) := "000001000000000000";  -- channel 123: impulse >> 4
    drive_data(data);
    data(17 downto 0) := "000000100000000000";  -- channel 124: impulse >> 5
    drive_data(data);
    data(17 downto 0) := "000000010000000000";  -- channel 125: impulse >> 6
    drive_data(data);
    data(17 downto 0) := "000000001000000000";  -- channel 126: impulse >> 7
    drive_data(data);
    data(17 downto 0) := "000000000100000000";  -- channel 127: impulse >> 8
    drive_data(data);
    drive_zeros(3200);

    -- End of test
    report "Not a real failure. Simulation finished successfully. Test completed successfully" severity failure;
    wait;

  end process stimuli;

  -----------------------------------------------------------------------
  -- Check outputs
  -----------------------------------------------------------------------

  check_outputs : process
    variable check_ok : boolean := true;
    -- Previous values of master DATA channel signals
    variable data_tvalid_prev : std_logic := '0';
    variable data_tready_prev : std_logic := '0';
    variable data_tdata_prev  : std_logic_vector(79 downto 0) := (others => '0');
    variable data_tlast_prev  : std_logic := '0';
  begin

    -- Check outputs T_STROBE time after rising edge of clock
    wait until rising_edge(aclk);
    wait for T_STROBE;

    -- Do not check the output payload values, as this requires the behavioral model
    -- which would make this demonstration testbench unwieldy.
    -- Instead, check the protocol of the master DATA channel:
    -- check that the payload is valid (not X) when TVALID is high
    -- and check that the payload does not change while TVALID is high until TREADY goes high

    if m_axis_data_tvalid = '1' and aresetn = '1' and aclken = '1' then
      if is_x(m_axis_data_tdata) then
        report "ERROR: m_axis_data_tdata is invalid when m_axis_data_tvalid is high" severity error;
        check_ok := false;
      end if;
      if is_x(m_axis_data_tlast) then
        report "ERROR: m_axis_data_tlast is invalid when m_axis_data_tvalid is high" severity error;
        check_ok := false;
      end if;

      if data_tvalid_prev = '1' and data_tready_prev = '0' then  -- payload must be the same as last cycle
        if m_axis_data_tdata /= data_tdata_prev then
          report "ERROR: m_axis_data_tdata changed while m_axis_data_tvalid was high and m_axis_data_tready was low" severity error;
          check_ok := false;
        end if;
        if m_axis_data_tlast /= data_tlast_prev then
          report "ERROR: m_axis_data_tlast changed while m_axis_data_tvalid was high and m_axis_data_tready was low" severity error;
          check_ok := false;
        end if;
      end if;

    end if;

    assert check_ok
      report "ERROR: terminating test with failures." severity failure;

    -- Record payload values for checking next clock cycle
    if check_ok and aclken = '1' then
      data_tvalid_prev := m_axis_data_tvalid;
      data_tready_prev := m_axis_data_tready;
      data_tdata_prev  := m_axis_data_tdata;
      data_tlast_prev  := m_axis_data_tlast;
    end if;

  end process check_outputs;

  -----------------------------------------------------------------------
  -- Assign TDATA / TUSER fields to aliases, for easy simulator waveform viewing
  -----------------------------------------------------------------------

  -- Data slave channel alias signals
  s_axis_data_tdata_path0       <= s_axis_data_tdata(17 downto 0);
  s_axis_data_tdata_path1       <= s_axis_data_tdata(41 downto 24);

  -- Config slave channel alias signals
  s_axis_config_tdata_filter_select   <= s_axis_config_tdata(6 downto 0);

  -- Data master channel alias signals: update these only when they are valid
  m_axis_data_tdata_path0       <= m_axis_data_tdata(33 downto 0) when m_axis_data_tvalid = '1';
  m_axis_data_tdata_path1       <= m_axis_data_tdata(73 downto 40) when m_axis_data_tvalid = '1';

end tb;
